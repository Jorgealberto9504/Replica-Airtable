// apps/backend/prisma/schema.prisma

// === Cliente de Prisma (genera tipos y métodos tipados) ===
generator client {
  provider = "prisma-client-js"
}

// === Fuente de datos: Postgres (URL viene de .env) ===
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL") // usa la conexión directa en migraciones
}

/* ============================================================
   ENUMS
   ============================================================ */

enum PlatformRole {
  USER
  SYSADMIN
}

enum BaseRole {
  EDITOR
  COMMENTER
  VIEWER
}

enum BaseVisibility {
  PUBLIC
  PRIVATE
}

enum FieldType {
  TEXT
  LONG_TEXT
  NUMBER
  CURRENCY
  CHECKBOX
  DATE
  DATETIME
  TIME          // minutos desde medianoche
  SINGLE_SELECT
  MULTI_SELECT
}

/* === NEW: Acciones de auditoría ============================================
   La app registrará un AuditEvent con una de estas acciones
   ========================================================================== */
enum AuditAction {
  // Base
  BASE_CREATED
  BASE_RENAMED
  BASE_VISIBILITY_CHANGED
  BASE_TRASHED
  BASE_RESTORED

  // Tabla
  TABLE_CREATED
  TABLE_RENAMED
  TABLE_TRASHED
  TABLE_RESTORED
  TABLE_REORDERED

  // Campo
  FIELD_CREATED
  FIELD_UPDATED
  FIELD_TRASHED
  FIELD_RESTORED

  // Registro
  RECORD_CREATED
  RECORD_UPDATED
  RECORD_TRASHED
  RECORD_RESTORED

  // Comentarios
  COMMENT_CREATED
  COMMENT_EDITED
  COMMENT_TRASHED

  // Miembros
  MEMBER_INVITED
  MEMBER_ROLE_CHANGED
  MEMBER_REMOVED
}

/* ============================================================
   MODELOS PRINCIPALES
   ============================================================ */

model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  fullName     String
  passwordHash String
  createdAt    DateTime @default(now())

  isActive           Boolean   @default(true)
  mustChangePassword Boolean   @default(true)
  passwordUpdatedAt  DateTime?

  platformRole   PlatformRole @default(USER)
  canCreateBases Boolean      @default(false)

  ownedBases      Base[]       @relation("BaseOwner")
  baseMembers     BaseMember[]
  ownedWorkspaces Workspace[]  @relation("WorkspaceOwner")

  fieldsCreated  Field[]     @relation("FieldCreatedBy")
  fieldsUpdated  Field[]     @relation("FieldUpdatedBy")
  recordsCreated RecordRow[] @relation("RecordRowCreatedBy")
  recordsUpdated RecordRow[] @relation("RecordRowUpdatedBy")

  recordCellsCreated RecordCell[] @relation("RecordCellCreatedBy")
  recordCellsUpdated RecordCell[] @relation("RecordCellUpdatedBy")

  // Comentarios
  commentsCreated Comment[] @relation("CommentAuthor") // escritos por este usuario
  commentsUpdated Comment[] @relation("CommentEditor") // editados por este usuario

  // NEW: eventos de auditoría generados por este usuario
  auditEvents AuditEvent[] @relation("AuditByUser")
}

model Workspace {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ownerId Int
  owner   User @relation("WorkspaceOwner", fields: [ownerId], references: [id])

  isTrashed Boolean   @default(false)
  trashedAt DateTime?

  bases Base[]

  @@unique([ownerId, name, isTrashed])
  @@index([ownerId])
  @@index([isTrashed])
  @@index([trashedAt])
}

model Base {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  workspaceId Int?
  workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  ownerId Int
  owner   User @relation("BaseOwner", fields: [ownerId], references: [id])

  visibility BaseVisibility @default(PRIVATE)

  isTrashed Boolean   @default(false)
  trashedAt DateTime?

  members BaseMember[]
  tables  TableDef[]

  // NEW: backref de auditoría (eventos de esta base)
  auditEvents AuditEvent[]

  @@unique([ownerId, name, isTrashed])
  @@index([ownerId])
  @@index([visibility])
  @@index([workspaceId])
  @@index([trashedAt])
  @@index([isTrashed])
}

model BaseMember {
  id        Int      @id @default(autoincrement())
  baseId    Int
  userId    Int
  role      BaseRole @default(VIEWER)
  createdAt DateTime @default(now())

  base Base @relation(fields: [baseId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([baseId, userId])
}

model TableDef {
  id        Int      @id @default(autoincrement())
  baseId    Int
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  position  Int      @default(0)

  isTrashed Boolean   @default(false)
  trashedAt DateTime?

  base    Base        @relation(fields: [baseId], references: [id], onDelete: Cascade)
  fields  Field[]
  records RecordRow[]

  // NEW: backref de auditoría
  auditEvents AuditEvent[]

  @@unique([baseId, name, isTrashed])
  @@index([baseId])
  @@index([trashedAt])
  @@index([isTrashed])
  @@index([baseId, position])
}

/* ============================================================
   COLUMNAS / REGISTROS
   ============================================================ */

model Field {
  id       Int       @id @default(autoincrement())
  tableId  Int
  name     String
  type     FieldType
  config   Json?
  position Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById Int?
  createdBy   User? @relation("FieldCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  updatedById Int?
  updatedBy   User? @relation("FieldUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)

  isTrashed Boolean   @default(false)
  trashedAt DateTime?

  table   TableDef       @relation(fields: [tableId], references: [id], onDelete: Cascade)
  cells   RecordCell[]
  options SelectOption[] // para SINGLE/MULTI

  // NEW: backref de auditoría
  auditEvents AuditEvent[]

  @@unique([tableId, name, isTrashed])
  @@index([tableId, position])
  @@index([isTrashed])
  @@index([trashedAt])
}

/* Opciones para SINGLE_SELECT / MULTI_SELECT */
model SelectOption {
  id      Int   @id @default(autoincrement())
  fieldId Int
  field   Field @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  label    String
  color    String?
  position Int     @default(0)

  isTrashed Boolean   @default(false)
  trashedAt DateTime?

  // m2m (MULTI_SELECT)
  usedBy RecordCellOption[]

  // backref del SINGLE_SELECT (Prisma lo infiere por selectOptionId)
  singleCells RecordCell[]

  @@unique([fieldId, label, isTrashed])
  @@index([fieldId, position])
  @@index([isTrashed])
  @@index([trashedAt])
}

model RecordRow {
  id      Int @id @default(autoincrement())
  tableId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById Int?
  createdBy   User? @relation("RecordRowCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  updatedById Int?
  updatedBy   User? @relation("RecordRowUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)

  isTrashed Boolean   @default(false)
  trashedAt DateTime?

  table TableDef     @relation(fields: [tableId], references: [id], onDelete: Cascade)
  cells RecordCell[]

  comments Comment[] // comentarios asociados a esta fila

  // NEW: backref de auditoría
  auditEvents AuditEvent[]

  @@index([tableId])
  @@index([updatedAt])
  @@index([isTrashed])
  @@index([trashedAt])
}

model RecordCell {
  id       Int @id @default(autoincrement())
  recordId Int
  fieldId  Int

  record RecordRow @relation(fields: [recordId], references: [id], onDelete: Cascade)
  field  Field     @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById Int?
  createdBy   User?    @relation("RecordCellCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  updatedById Int?
  updatedBy   User?    @relation("RecordCellUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)

  // valores por tipo
  stringValue   String?
  numberValue   Decimal?
  boolValue     Boolean?
  dateValue     DateTime?
  datetimeValue DateTime?

  // TIME
  timeMinutes Int?

  // SINGLE_SELECT (relación directa)
  selectOptionId Int?
  selectOption   SelectOption? @relation(fields: [selectOptionId], references: [id], onDelete: SetNull)

  // MULTI_SELECT (m2m)
  options RecordCellOption[]

  @@unique([recordId, fieldId])
  @@index([fieldId])
  @@index([numberValue])
  @@index([datetimeValue])
}

model RecordCellOption {
  recordCellId Int
  optionId     Int
  createdAt    DateTime @default(now())

  recordCell RecordCell   @relation(fields: [recordCellId], references: [id], onDelete: Cascade)
  option     SelectOption @relation(fields: [optionId], references: [id], onDelete: Cascade)

  @@id([recordCellId, optionId])
  @@index([optionId])
}

/* ============================================================
   COMENTARIOS (por fila, sin hilos)
   ============================================================ */
model Comment {
  id          Int       @id @default(autoincrement())                           // id del comentario
  recordId    Int                                                             // FK a la fila comentada
  record      RecordRow  @relation(fields: [recordId], references: [id], onDelete: Cascade)

  body        String                                                            // contenido

  createdAt   DateTime   @default(now())                                        // creado
  updatedAt   DateTime   @updatedAt                                             // última edición

  createdById Int?                                                               // autor (nullable)
  createdBy   User?      @relation("CommentAuthor", fields: [createdById], references: [id], onDelete: SetNull)
  updatedById Int?                                                               // último editor
  updatedBy   User?      @relation("CommentEditor", fields: [updatedById], references: [id], onDelete: SetNull)

  isTrashed   Boolean    @default(false)                                         // soft delete
  trashedAt   DateTime?                                                          // cuándo se mandó a papelera

  @@index([recordId, createdAt])
  @@index([isTrashed])
  @@index([trashedAt])
}

/* ============================================================
   NEW: AUDITORÍA (historial de eventos)
   - Un registro por acción relevante (crear/renombrar/trash/etc.)
   - Siempre ligado a una Base (baseId); opcionalmente a tabla/fila/campo.
   - Guarda actor (userId, ip), acción (enum) y payload (details) para diffs.
   ============================================================ */
model AuditEvent {
  id        BigInt   @id @default(autoincrement())                 // id grande para alto volumen
  createdAt DateTime @default(now())                               // timestamp del evento

  // actor
  userId Int?                                                       // usuario que ejecutó (nullable)
  user   User? @relation(name: "AuditByUser", fields: [userId], references: [id], onDelete: SetNull)
  ip     String?                                                    // IP opcional

  // ámbito
  baseId  Int                                                       // siempre pertenece a una base
  base    Base      @relation(fields: [baseId], references: [id], onDelete: Cascade)
  tableId Int?
  table   TableDef?  @relation(fields: [tableId], references: [id], onDelete: SetNull)
  recordId Int?
  record  RecordRow? @relation(fields: [recordId], references: [id], onDelete: SetNull)
  fieldId Int?
  field   Field?     @relation(fields: [fieldId], references: [id], onDelete: SetNull)

  // acción
  action  AuditAction                                               // código de acción
  summary String                                                    // descripción legible (UI)
  details Json?                                                     // payload/diff opcional

  @@index([baseId, createdAt])
  @@index([tableId])
  @@index([recordId])
  @@index([fieldId])
  @@index([userId])
}